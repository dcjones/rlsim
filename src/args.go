/*
* Copyright (C) 2013 EMBL - European Bioinformatics Institute
*
* This program is free software: you can redistribute it
* and/or modify it under the terms of the GNU General
* Public License as published by the Free Software
* Foundation, either version 3 of the License, or (at your
* option) any later version.
*
* This program is distributed in the hope that it will be
* useful, but WITHOUT ANY WARRANTY; without even the
* implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*
* Neither the institution name nor the name rlsim
* can be used to endorse or promote products derived from
* this software without prior written permission. For
* written permission, please contact <sbotond@ebi.ac.uk>.

* Products derived from this software may not be called
* rlsim nor may rlsim appear in their
* names without prior written permission of the developers.
* You should have received a copy of the GNU General Public
* License along with this program. If not, see
* <http://www.gnu.org/licenses/>.
 */

package main

import (
	"flag"
	"fmt"
	"os"
	"strings"
)

// Sub-structs to hold command line arguments:

type FragMethod struct {
	Name  string
	Param int
}

type EffParam struct {
	Shape float64
	Min   float64
	Max   float64
}

// Struct to hold command line arguments:
type CmdArgs struct {
	ReqFrags       int64
	NrCycles       int64
	StrandBias     float64
	PrimingTemp    float64
	PrimingRejects bool
	FixedEff       float64
	GcEffParam     *EffParam
	LenEffParam    *EffParam
	ReportFile     string
	Verbose        bool
	TargetMix      *TargetMix
	FragMethod     *FragMethod
	FragLossProb   float64
	InputFiles     []string
	MaxProcs       int64
	ProfFile       string
	KmerLength     uint32
	GobDir         string
	GCFreq         int
	PolyAParam     *TargetMix
	InitSeed       int64
	PcrSeed        int64
	SamplingSeed   int64
	RawParamsFile  string
	RawGcEffs      []float64
	RawLenProbs    *LenProbStruct
	MinRawGcEff    float64
	ExprMul        float64
}

// Parse command line arguments using the flag package.
func (a *CmdArgs) Parse() {
	var targMix string
	var fragMethod string
	var gcEffParams string
	var lenEffParams string
	var polyAParams string
	var help, version, gob bool
	var kmerLenght int
	var randtest bool

	// Default target mixture:
	const target_mix_default = "1.0:sn:(189, 24, -1.09975, 76, 294)" // estimated from SRR521457.
	const polyA_mix_default = "1.0:g:(150,1,0,220)"

	// Process simple command line parameters:
	flag.Int64Var(&a.ReqFrags, "n", 0, "Number of requested fragments.")
	flag.StringVar(&targMix, "d", target_mix_default, "Fragment size distribution.")
	flag.Int64Var(&a.NrCycles, "c", 11, "Number of PCR cycles.")
	flag.StringVar(&polyAParams, "a", polyA_mix_default, "Poly(A) tail length distribution.")
	flag.Float64Var(&a.StrandBias, "b", 0.5, "Strand bias.")
	flag.Float64Var(&a.PrimingTemp, "p", 5.0, "Priming bias parameter.")
	flag.BoolVar(&a.PrimingRejects, "pr", false, "Priming bias affects number of fragments")
	flag.IntVar(&kmerLenght, "k", 6, "Primer length.")
	flag.Float64Var(&a.FixedEff, "e", 0.0, "Fixed per-cyle PCR efficiency.")
	flag.StringVar(&gcEffParams, "eg", "", "GC efficiency parameters")
	flag.StringVar(&lenEffParams, "el", "(0.0,1.0,1.0)", "Length efficiency parameters")
	flag.StringVar(&a.RawParamsFile, "j", "", "Raw parameter file generated by effest.")
	flag.Float64Var(&a.MinRawGcEff, "jm", 0.0, "Minimum raw GC efficiency.")
	flag.StringVar(&a.ReportFile, "r", "rlsim_report.json", "Report file.")
	flag.Int64Var(&a.MaxProcs, "t", 4, "Number of cores to use.")
	flag.StringVar(&fragMethod, "f", "after_prim_double", "Fragmentation method.")
	flag.Float64Var(&a.FragLossProb, "flg", 0.0, "Fragment loss probability.")
	flag.Float64Var(&a.ExprMul, "m", 1.0, "Expression level multiplier.")
	flag.BoolVar(&gob, "g", false, "Keep fragments in memory.")
	flag.Int64Var(&a.InitSeed, "si", 0, "Initial random seed.")
	flag.Int64Var(&a.PcrSeed, "sp", 0, "PCR amplification random seed.")
	flag.Int64Var(&a.SamplingSeed, "ss", 0, "Sampling random seed.")
	flag.StringVar(&a.GobDir, "gobdir", "", "Directory to store gob files.")
	flag.IntVar(&a.GCFreq, "gcfreq", 100, "Force garbage collection after processing <gcfreq> transcripts.")
	flag.StringVar(&a.ProfFile, "prof", "", "Write out CPU profiling information.")
	flag.BoolVar(&help, "h", false, "Print out help message.")
	flag.BoolVar(&version, "V", false, "Print out version.")
	flag.BoolVar(&a.Verbose, "v", false, "Toggle verbose mode.")
	flag.BoolVar(&randtest, "randt", false, "Generate random numbers for testing.")

	// Redefine usage:
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Simulate RNA-seq library preparation with priming biases, PCR biases and size selection (version: %s).\n\n", VERSION)
		fmt.Fprintf(os.Stderr, `Usage:
        rlsim [arguments] [transcriptome fasta files (optional)]

Optional arguments:
                argument                    type    default  
        -n      requested fragments         int     
        -d      fragment size distribution  string  "1.0:sn:(189, 24, -1.09975, 76, 294)" 
        -f      fragmentation method        string  "after_prim_double"
        -b      strand bias                 float   0.5
        -c      PCR cycles                  int     11
        -p      priming bias parameter      float   5.0
        -pr     priming bias affects        bool    false
                nuber of fragments from a
                transcript
        -k      primer length               int     6
        -a      poly(A) tail size dist.     string  [check source]
        -flg    fragment loss probability   float   0.0
        -m      expression level multiplier float   1.0
        -e      fixed PCR efficiency        float   0.0
        -eg     GC efficiency parameters 
                as "(shape, min, max)":     raw from SRR521457
        -el     length efficiency parameters 
                as "(shape, min, max)":
                    shape                   float   0.0
                    min                     float   1.0
                    max                     float   1.0
        -j      raw parameter file          string  
                superseeds -d, -c, -eg
        -jm     minimum raw gc efficiency   float   0.0
        -r      report file                 string  "rlsim_report.json"
        -t      number of cores to use      int     4
        -g      keep fragments in memory    bool    false
        -si     initial random seed         int     from UTC time
        -sp     pcr random seed             int     auto
        -ss     sampling random seed        int     auto
        -gobdir fragment directory          string  "rlsim_gob_$PID"
        -v      toggle verbose mode         bool    false
        -h      print usage and exit        bool    false
        -V      print version and exit      bool    false
        -prof   write CPU profiling info    string  ""
        -gcfreq trigger garbage collection  int     100
                after this many transcripts
        -randt  generate RNG test files     bool    false

Examples:
        rlsim -n 2000000 transcripts.fa
        cat transcripts.fa | rlsim -n 2000000

For more details consult the package manual at:
        https://github.com/sbotond/rlsim/tree/master/doc/rlsim_manual.pdf
`)
		os.Exit(0)
	}

	flag.Parse()
	// Print usage:
	if help {
		flag.Usage()
		os.Exit(0)
	}
	// Print version:
	if version {
		fmt.Printf("%s\n", VERSION)
		os.Exit(0)
	}

	// Raw GC efficiencies estimated from SRR521457 (see http://bit.ly/rlsim-pl):
	EffSRR521457 := []float64{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.6214855142919264, 0.4159233164222049, 0.44285355190022124, 0.5111795670132255, 0.5261218695690415, 0.5657937478213575, 0.6057227372065885, 0.652512493251505, 0.6551266520303076, 0.6586493220034146, 0.6710292671335725, 0.6828989286775027, 0.7103061475969692, 0.7145967526946446, 0.7125612213162864, 0.7158400735145201, 0.7361963080537015, 0.7507700417579295, 0.7936248041169689, 0.8745263930903109, 0.8971210947107862, 0.8979381841721974, 0.8723089598770069, 0.8768516147049334, 0.8892267818464259, 0.9064925780415922, 0.9077163532915999, 0.8951126800219693, 0.9176033189485007, 0.9116016387064556, 0.8890492343084937, 0.8803727480781831, 0.8898403139631976, 0.9348273906591118, 0.9387867073874407, 0.9213150498959719, 0.8888279850470155, 0.8918981127741714, 0.8604755993712578, 0.8382051613193982, 0.8515837826695183, 0.858730482918872, 0.8415828215289731, 0.8190334105144152, 0.8317518172797949, 0.8079382135754152, 0.7900809748209163, 0.7800701153643972, 0.7698151649955114, 0.7549149228315972, 0.7393688207123867, 0.7085441619225441, 0.7010892852241013, 0.6740704877921768, 0.6613179904098958, 0.6424878029890573, 0.6351387703085332, 0.6218820987970053, 0.5928624580840685, 0.5646145379419862, 0.5097661577740067, 0.5432830324275337, 0.5100248798209441, 0.47253575285403415, 0.3571200478171759, 0.31034679770879103, 0.23330181449341403, 0.07433564353203437, 0, 0.27666333287124445, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

	// Parse efficiency parameter strings:
	defaultRawGcFlag := false
	if gcEffParams != "" {
		a.GcEffParam = ParseEffParamString(gcEffParams)
	} else {
		a.RawGcEffs = EffSRR521457
		defaultRawGcFlag = true
	}
	a.LenEffParam = ParseEffParamString(lenEffParams)

	// Check primer length:
	if kmerLenght < 1 {
		flag.Usage()
		L.Fatal("Invalid primer length!")
	}
	a.KmerLength = uint32(kmerLenght)

	// Check frgament loss probability:
	if a.FragLossProb < 0.0 || a.FragLossProb > 1 {
		L.Fatalf("The fragment loss probability must be in the interval [0, 1]!")
	}

	// Parse Poly(A) tail parameters.
	a.PolyAParam = ParsePolyAParamString(polyAParams)

	// Generate random numbers for testing:
	if randtest {
		RandTest()
		os.Exit(0)
	}

	// Check the number of requested fragments:
	if a.ReqFrags < 0 {
		flag.Usage()
		L.Fatal("Illegal fragment number!")
	}

	// Parse target mixture string:
	a.TargetMix = parseTargetMixString(targMix)
	// Parse fragmentation method string:
	a.FragMethod = parseFragMethodString(fragMethod)

	// Set gob directory
	if !gob && a.GobDir == "" {
		a.GobDir = "rlsim_gob_" + fmt.Sprintf("%d", os.Getpid())
	}

	// Set input files
	a.InputFiles = flag.Args()

	// Parse raw parameter file if present:
	if a.RawParamsFile != "" {
		rp := DecodeRawParams(a.RawParamsFile)
		if a.ReqFrags == 0 {
			a.ReqFrags = rp.ReqFrags
		}
		a.NrCycles = rp.NrCycles
		a.RawLenProbs = &rp.TargetProbs
		a.RawGcEffs = rp.GcEffs
	}

	// Warn about using default raw GC efficiencies:
	if defaultRawGcFlag && (a.ReqFrags > 0) && a.RawParamsFile == "" {
		L.Println("WARNING: Using raw efficiencies estimated from SRR521457 by default")
		L.Println("(see http://bit.ly/rlsim-pl and http://bit.ly/rlsim-pa for the details).")
	}

	if a.ReqFrags == 0 {
		fmt.Fprintf(os.Stderr, "No fragments requested! Exiting.\n")
		flag.Usage()
	}

}

// Dealt with the fragmentation methods:

func (fm *FragMethod) String() (s string) {
	s = fmt.Sprintf("[ name: %s, param: %d ]", fm.Name, fm.Param)
	return
}

func parseFragMethodString(s string) *FragMethod {
	fm := new(FragMethod)

	spl := strings.Split(s, ":")
	err_str := "Malformed fragmentation method string: "

	if len(spl) > 2 || len(spl) < 1 {
		L.Fatal(err_str + s)
	}

	switch spl[0] {
	case "pre_prim", "after_prim", "after_prim_double", "after_noprim_double", "after_noprim", "prim_jump":
		fm.Name = spl[0]
	default:
		L.Fatal(err_str + s)
	}

	if len(spl) == 2 {
		_, err := fmt.Sscanf(spl[1], "%d", &fm.Param)
		if err != nil {
			L.Fatal(err_str + s)
		}
	}

	// pre_prim method needs a parameter no matter what!
	if fm.Name == "pre_prim" && fm.Param == 0 {
		fm.Param = 2000
	}

	return fm
}

// Parse efficiency parameter string:
func ParseEffParamString(s string) *EffParam {
	p := new(EffParam)
	s = strings.TrimSpace(s)
	if s[0] != '(' || s[len(s)-1] != ')' {
		L.Fatal("Missing paranthesis in efficiency parameter string: " + s)
	}
	s = s[1 : len(s)-1]
	n, e := fmt.Sscanf(s, "%f,%f,%f", &p.Shape, &p.Min, &p.Max)
	if n == 0 || e != nil {
		L.Fatal("Failed to parse efficieny parameter string: " + s)
	}

	if p.Shape < 0 {
		L.Fatalf("Efficiency shape parameter %g is negative!", p.Shape)
	}
	if p.Min < 0 || p.Min > 1.0 {
		L.Fatalf("The minimum efficiency %g is outside the range [0, 1]!", p.Min)
	}
	if p.Max < 0 || p.Max > 1.0 {
		L.Fatalf("The maximum efficiency %g is outside the range [0, 1]!", p.Max)
	}

	return p
}

func (p *EffParam) String() string {
	s := fmt.Sprintf("(%g, %g, %g)", p.Shape, p.Min, p.Max)
	return s
}

func ParsePolyAParamString(s string) *TargetMix {
	m := parseTargetMixString(s)
	return m
}
